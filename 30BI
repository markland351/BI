// worker.js - 完整增强版：自动抓取、测速排序、保留前30名
// 部署环境：Cloudflare Workers

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  const url = new URL(request.url)
  const debugMode = url.searchParams.has('debug')
  
  // 1. 配置区 'vless://5f566125-43e5-4521-cc18-221ad54d7bb5@1.1.1.1:8080?encryption=none&security=none&type=ws&host=89.20060705.xyz&path=%2F123#89.20060705.xyz-clone',
  const originalVless = 'vless://88c535d8-8c25-4b04-c19b-b3dcbea85cca@1.1.1.1:8443?encryption=none&security=tls&sni=23.20060705.xyz&fp=chrome&insecure=1&allowInsecure=1&type=ws&host=23.20060705.xyz&path=%2F#23'
  const sources = [
    { name: 'fast', url: 'https://yx.20060705.xyz/fast-ips.txt' },
    { name: 'hubbylei', url: 'https://raw.githubusercontent.com/hubbylei/bestcf/refs/heads/main/bestcf.txt' },
    { name: 'gslege-All', url: 'https://raw.githubusercontent.com/gslege/CloudflareIP/refs/heads/main/All.txt' },
    { name: 'chris202010-yxym', url: 'https://raw.githubusercontent.com/chris202010/yxym/refs/heads/main/ip.txt' },
    { name: 'chris202010-yxip', url: 'https://raw.githubusercontent.com/chris202010/yxip/refs/heads/main/ip.txt' },
    { name: 'Senflare', url: 'https://raw.githubusercontent.com/Senflare/Senflare-IP/refs/heads/main/IPlist.txt' },
    { name: 'Jackiegee857', url: 'https://raw.githubusercontent.com/Jackiegee857/yx777/refs/heads/main/ip.txt' },
    { name: 'camel52zhang', url: 'https://raw.githubusercontent.com/camel52zhang/yxip/refs/heads/main/ip.txt' },
    { name: 'wh245', url: 'https://raw.githubusercontent.com/wh245/yxip/refs/heads/main/ip.txt' },
    { name: 'qq601359558', url: 'https://raw.githubusercontent.com/qq601359558/yxIpTest/refs/heads/main/ip.txt' },
    { name: 'fangke1982', url: 'https://raw.githubusercontent.com/fangke1982/yx/refs/heads/main/ips.txt' }
  ]
  

  try {
    // 2. 抓取并提取所有 IP
    let allIPs = new Set()
    const fetchPromises = sources.map(async (source) => {
      try {
        const resp = await fetch(source.url, {
          headers: { 'User-Agent': 'Mozilla/5.0' },
          cf: { cacheTtl: 1800 } 
        })
        if (resp.ok) {
          const text = await resp.text()
          const matches = text.match(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g) || []
          matches.forEach(ip => {
            if (!['1.1.1.1', '1.0.0.1', '8.8.8.8', '127.0.0.1'].includes(ip)) {
              allIPs.add(ip)
            }
          })
        }
      } catch (e) {
        console.error(`Fetch ${source.name} failed:`, e)
      }
    })

    await Promise.all(fetchPromises)
    let uniqueIPs = Array.from(allIPs)

    // 为避免 Worker 超时，我们对前 80 个 IP 进行并发测速
    let testBatch = uniqueIPs.slice(0, 80)

    // 4. 并发测速逻辑 (测算 CF 节点到目标的 RTT)
    const speedResults = await Promise.all(
      testBatch.map(async (ip) => {
        const controller = new AbortController()
        const timeoutId = setTimeout(() => controller.abort(), 1200) // 1.2秒超时
        const start = Date.now()
        
        try {
          // 通过 HEAD 请求探测
          await fetch(`http://${ip}`, { 
            method: 'HEAD', 
            mode: 'no-cors',
            signal: controller.signal 
          })
          const latency = Date.now() - start
          return { ip, latency, status: 'ok' }
        } catch (e) {
          return { ip, latency: 9999, status: 'fail' }
        } finally {
          clearTimeout(timeoutId)
        }
      })
    )

    // 5. 排序并筛选
    // 过滤掉失败的，按延迟升序排，取前 30 名
    const sortedIPs = speedResults
      .filter(res => res.status === 'ok')
      .sort((a, b) => a.latency - b.latency)
      .slice(0, 30)

    // 6. 调试输出
    if (debugMode) {
      return new Response(JSON.stringify({
        total_scanned: uniqueIPs.length,
        tested_batch: testBatch.length,
        top_results: sortedIPs
      }, null, 2), { headers: { 'Content-Type': 'application/json' } })
    }

    // 7. 生成最终节点列表
    if (sortedIPs.length === 0) {
      return new Response("No healthy nodes found. Try again later.", { status: 404 })
    }

    const finalConfig = sortedIPs.map((item, index) => {
      const rank = (index + 1).toString().padStart(2, '0')
      // 替换 IP 并修改备注名，加入延迟信息
      let link = originalVless.replace('1.1.1.1', item.ip)
      // 处理备注名：把原有备注替换或追加
      const urlObj = new URL(link.replace('#', '?hash=')) 
      const originalAlias = link.split('#')[1] || 'node'
      const newAlias = `${rank}-Latency-${item.latency}ms-${item.ip}`
      return link.split('#')[0] + '#' + newAlias
    }).join('\n')

    // 8. 返回结果
    return new Response(finalConfig, {
      headers: {
        'Content-Type': 'text/plain; charset=utf-8',
        'Cache-Control': 'public, max-age=3600'
      }
    })

  } catch (err) {
    return new Response(`Internal Error: ${err.message}`, { status: 500 })
  }
}
